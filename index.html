<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Betűvadász – J vs LY (Modern Prototype)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #070a14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { height: 100%; display: grid; place-items: center; padding: 10px; box-sizing: border-box; }
    .panel { width: min(980px, 100%); }
    canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 920 / 560;
      display: block;
      background: radial-gradient(circle at 30% 20%, #1a2560 0%, #0b1020 55%, #060815 100%);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      touch-action: none;
    }
    .hint {
      margin-top: 10px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap;
      color: rgba(232,238,252,0.92);
      font-size: 13px;
    }
    kbd { background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 6px; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.16); background: rgba(255,255,255,0.07); }
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <canvas id="game" width="920" height="560" aria-label="Betűvadász játék"></canvas>
    <div class="hint">
      <div class="pill">Az űrhajó középen halad | Lőj: <kbd>J</kbd> vagy <kbd>L</kbd> (LY)</div>
      <div class="pill">Mobil: lőj a képernyő alján lévő gombokkal</div>
      <div class="pill">Újraindítás: <kbd>R</kbd> | Szünet: <kbd>P</kbd></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const W = canvas.width, H = canvas.height;

  // Word bank: only words where the missing chunk is exactly "j" or "ly" in one place.
  const WORDS = [
    // J
    { full: "játék", missing: "j" },
    { full: "jó", missing: "j" },
    { full: "juh", missing: "j" },
    { full: "jég", missing: "j" },
    { full: "jár", missing: "j" },
    { full: "jel", missing: "j" },
    { full: "jön", missing: "j" },
    { full: "kaja", missing: "j" },
    { full: "fajta", missing: "j" },
    { full: "hajó", missing: "j" },

    // LY
    { full: "lyuk", missing: "ly" },
    { full: "golyó", missing: "ly" },
    { full: "hely", missing: "ly" },
    { full: "folyó", missing: "ly" },
    { full: "pálya", missing: "ly" },
    { full: "gólya", missing: "ly" },
    { full: "pehely", missing: "ly" },
    { full: "súly", missing: "ly" },
    { full: "olyan", missing: "ly" },
    { full: "bólya", missing: "ly" },
  ];

  // ---------- Utility ----------
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const SLOT = "⟦⚡⟧";

  function buildMaskedWord(full, missing) {
    const idx = full.indexOf(missing);
    if (idx === -1) return full;
    return `${full.slice(0, idx)}${SLOT}${full.slice(idx + missing.length)}`;
  }

  WORDS.forEach((word) => {
    word.masked = buildMaskedWord(word.full, word.missing);
  });

  // ---------- Game state ----------
  let score = 0;
  let lives = 3;
  let time = 0;
  let gameOver = false;
  let paused = false;

  // Difficulty ramps
  let spawnInterval = 1200;  // ms
  let baseSpeed = 70;        // px/s
  let maxObstacles = 2;

  // Entities
  const obstacles = [];
  const bullets = [];
  const particles = [];
  const popups = [];

  // Player
  const player = {
    x: W / 2,
    y: H / 2,
    radius: 18,
    cooldown: 0,
    lastWeapon: "j",
  };

  function pickWord() {
    return WORDS[Math.floor(Math.random() * WORDS.length)];
  }

  function spawnObstacle() {
    if (obstacles.length >= maxObstacles) return;

    const w = pickWord();
    const x = rand(120, W - 120);
    const y = -40;

    obstacles.push({
      x, y,
      speed: baseSpeed * rand(0.95, 1.35),
      radius: 28,
      wobble: rand(0, Math.PI * 2),
      word: w,
      slotCharge: null,
      completed: false,
      revealTimer: 0,
    });
  }

  function addParticles(x, y, intensity = 18) {
    for (let i = 0; i < intensity; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(80, 420);
      particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        r: rand(1.5, 3.6),
        t: 0,
        dur: rand(0.25, 0.7),
        kind: Math.random() < 0.55 ? "warm" : "hot"
      });
    }
  }

  function addPopupWord(x, y, fullWord, ok) {
    popups.push({
      x, y,
      t: 0,
      dur: 0.85,
      text: fullWord,
      ok
    });
  }

  function damage() {
    lives -= 1;
    // Screen shake
    shake.time = 0.14;
    shake.amp = 10;

    if (lives <= 0) gameOver = true;
  }

  const shake = { time: 0, amp: 0 };

  function shoot(type) {
    if (gameOver || paused) return;
    if (player.cooldown > 0) return;

    player.lastWeapon = type;
    player.cooldown = 0.12; // modern feel: light fire rate limit

    bullets.push({
      x: player.x,
      y: player.y - 12,
      vy: -760,
      r: 6,
      type // "j" or "ly"
    });

    // muzzle particles
    addParticles(player.x, player.y - 22, 6);
  }

  // ---------- Controls ----------
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "j") shoot("j");
    if (k === "l") shoot("ly"); // L means LY
    if (k === "r") reset();
    if (k === "p") paused = !paused;
    if (k === " " || k === "spacebar") shoot(player.lastWeapon);
  });

  // Pointer / touch:
  // - Tap the left button area shoots J, right button area shoots LY

  canvas.addEventListener("pointerdown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (W / rect.width);
    const py = (e.clientY - rect.top) * (H / rect.height);

    if (gameOver) return;

    // Bottom buttons region
    const btnY = H - 44, btnH = 30;
    const leftBtn = { x: W/2 - 230, y: btnY, w: 210, h: btnH };
    const rightBtn = { x: W/2 + 20, y: btnY, w: 210, h: btnH };

    if (py >= btnY && py <= btnY + btnH) {
      if (px >= leftBtn.x && px <= leftBtn.x + leftBtn.w) shoot("j");
      if (px >= rightBtn.x && px <= rightBtn.x + rightBtn.w) shoot("ly");
      return;
    }

    // Tap anywhere else: pick by side (left=J right=LY) for convenience
    shoot(px < W/2 ? "j" : "ly");
  });

  // ---------- Loop ----------
  let last = performance.now();
  let spawnAccMs = 0;

  function update(dt) {
    if (paused || gameOver) return;

    time += dt;
    spawnAccMs += dt * 1000;

    // Difficulty curve: every 12 seconds it ramps
    const phase = Math.floor(time / 12);
    baseSpeed = 70 + phase * 12;
    spawnInterval = clamp(1200 - phase * 80, 620, 1200);
    maxObstacles = clamp(2 + Math.floor(phase / 2), 2, 4);

    // Spawn obstacles
    while (spawnAccMs >= spawnInterval) {
      spawnAccMs -= spawnInterval;
      spawnObstacle();
    }

    // Cooldown
    if (player.cooldown > 0) player.cooldown = Math.max(0, player.cooldown - dt);

    // Obstacles move (forward scroll)
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const s = obstacles[i];
      s.wobble += dt * 2.1;
      s.x += Math.sin(s.wobble) * dt * 18;
      s.y += s.speed * dt;

      if (s.completed) {
        s.revealTimer = Math.max(0, s.revealTimer - dt);
        if (s.revealTimer <= 0) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Reached player lane => damage
      if (!s.completed && s.y > player.y + 40) {
        obstacles.splice(i, 1);
        damage();
      }
    }

    // Bullets move
    for (let i = bullets.length - 1; i >= 0; i--) {
      bullets[i].y += bullets[i].vy * dt;
      if (bullets[i].y < -30) bullets.splice(i, 1);
    }

    // Collisions
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
      const b = bullets[bi];
      for (let si = obstacles.length - 1; si >= 0; si--) {
        const s = obstacles[si];
        if (s.completed) continue;
        const dx = b.x - s.x;
        const dy = b.y - s.y;
        const rr = (b.r + s.radius) * (b.r + s.radius);
        if (dx*dx + dy*dy <= rr) {
          // Hit
          bullets.splice(bi, 1);

          const correct = (b.type === s.word.missing);
          if (correct) {
            score += 12;
            s.completed = true;
            s.revealTimer = 0.35;

            shake.time = 0.08;
            shake.amp = 6;

            addParticles(s.x, s.y, 26);
            addPopupWord(s.x, s.y, s.word.full, true);
          } else {
            // Wrong energy => slot flickers but stays empty
            s.slotCharge = b.type;
            shake.time = 0.05;
            shake.amp = 4;

            addParticles(s.x, s.y, 18);
            addPopupWord(s.x, s.y, s.word.masked, false);
          }
          break;
        }
      }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.92;
      p.vy *= 0.92;
      if (p.t >= p.dur) particles.splice(i, 1);
    }

    // Popups (texts)
    for (let i = popups.length - 1; i >= 0; i--) {
      popups[i].t += dt;
      if (popups[i].t >= popups[i].dur) popups.splice(i, 1);
    }

    // Screen shake decay
    if (shake.time > 0) shake.time = Math.max(0, shake.time - dt);
  }

  // ---------- Render ----------
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // screen shake
    const sx = shake.time > 0 ? rand(-shake.amp, shake.amp) : 0;
    const sy = shake.time > 0 ? rand(-shake.amp, shake.amp) : 0;

    ctx.save();
    ctx.translate(sx, sy);

    drawStars();
    drawHUD();
    drawObstacles();
    drawBullets();
    drawParticles();
    drawPlayer();
    drawButtons();
    drawPopups();

    ctx.restore();

    if (gameOver) drawGameOver();
  }

  function drawStars() {
    // Lightweight parallax-ish stars (no heavy loops)
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    for (let i = 0; i < 80; i++) {
      const x = (i * 113) % W;
      const y = (i * 71 + (time * 40)) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(232,238,252,0.95)";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Pont: ${score}`, 18, 28);
    ctx.fillText(`Élet: ${"❤".repeat(lives)}${"·".repeat(3 - lives)}`, 18, 52);

    ctx.fillStyle = "rgba(232,238,252,0.75)";
    ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Fegyver: ${player.lastWeapon.toUpperCase()} (Space = ismétlés)`, 18, 74);

    if (paused) {
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "28px system-ui";
      ctx.fillText("Szünet (P)", W/2 - 78, H/2);
    }
    ctx.restore();
  }

  function drawPlayer() {
    // ship body
    ctx.save();
    ctx.translate(player.x, player.y);

    // glow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(120,190,255,1)";
    ctx.beginPath();
    ctx.arc(0, 0, 34, 0, Math.PI * 2);
    ctx.fill();

    // core
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.beginPath();
    ctx.arc(0, 0, 24, 0, Math.PI * 2);
    ctx.fill();

    // triangle
    ctx.fillStyle = "rgba(255,255,255,0.42)";
    ctx.beginPath();
    ctx.moveTo(-18, 12);
    ctx.lineTo(0, -22);
    ctx.lineTo(18, 12);
    ctx.closePath();
    ctx.fill();

    // engine flame
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = "rgba(255,180,90,1)";
    ctx.beginPath();
    ctx.ellipse(0, 20, 7, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawObstacles() {
    for (const s of obstacles) {
      ctx.save();
      ctx.translate(s.x, s.y);

      const charged = s.slotCharge && !s.completed;
      ctx.fillStyle = charged ? "rgba(130,150,255,0.16)" : "rgba(255,255,255,0.10)";
      ctx.beginPath();
      ctx.arc(0, 0, s.radius, 0, Math.PI * 2);
      ctx.fill();

      if (charged) {
        ctx.strokeStyle = s.slotCharge === "j" ? "rgba(90,140,255,0.6)" : "rgba(210,120,255,0.6)";
      } else {
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
      }
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, s.radius, 0, Math.PI * 2);
      ctx.stroke();

      // word
      ctx.fillStyle = "rgba(232,238,252,0.98)";
      ctx.font = "20px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(s.completed ? s.word.full : s.word.masked, 0, 1);

      ctx.restore();
    }
  }

  function drawBullets() {
    for (const b of bullets) {
      ctx.save();
      ctx.translate(b.x, b.y);

      // trail
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = (b.type === "j") ? "rgba(90,140,255,1)" : "rgba(210,120,255,1)";
      ctx.fillRect(-2, 0, 4, 18);

      // head
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(0, 0, b.r, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }

  function drawParticles() {
    for (const p of particles) {
      const a = 1 - (p.t / p.dur);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = p.kind === "warm" ? "rgba(255,220,140,1)" : "rgba(255,120,120,1)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawButtons() {
    const btnY = H - 44, btnH = 30;
    const leftBtn = { x: W/2 - 230, y: btnY, w: 210, h: btnH };
    const rightBtn = { x: W/2 + 20, y: btnY, w: 210, h: btnH };

    ctx.save();
    // left
    ctx.fillStyle = "rgba(90,140,255,0.18)";
    roundRect(leftBtn.x, leftBtn.y, leftBtn.w, leftBtn.h, 12);
    ctx.fill();
    ctx.strokeStyle = "rgba(90,140,255,0.38)";
    ctx.lineWidth = 1;
    roundRect(leftBtn.x, leftBtn.y, leftBtn.w, leftBtn.h, 12);
    ctx.stroke();

    ctx.fillStyle = "rgba(232,238,252,0.95)";
    ctx.font = "14px system-ui";
    ctx.fillText("J-lézer (J)", leftBtn.x + 18, leftBtn.y + 20);

    // right
    ctx.fillStyle = "rgba(210,120,255,0.18)";
    roundRect(rightBtn.x, rightBtn.y, rightBtn.w, rightBtn.h, 12);
    ctx.fill();
    ctx.strokeStyle = "rgba(210,120,255,0.40)";
    ctx.lineWidth = 1;
    roundRect(rightBtn.x, rightBtn.y, rightBtn.w, rightBtn.h, 12);
    ctx.stroke();

    ctx.fillStyle = "rgba(232,238,252,0.95)";
    ctx.fillText("LY-plazma (L)", rightBtn.x + 18, rightBtn.y + 20);

    ctx.restore();
  }

  function drawPopups() {
    for (const p of popups) {
      // Two popup types:
      // 1) word popup: has x,y
      // 2) center banner: only text/sub
      if (typeof p.x === "number") {
        const prog = p.t / p.dur;
        const y = p.y - 18 - prog * 26;
        ctx.save();
        ctx.globalAlpha = 1 - prog;
        ctx.textAlign = "center";
        ctx.font = "16px system-ui";
        ctx.fillStyle = p.ok ? "rgba(160,255,190,0.95)" : "rgba(255,170,170,0.95)";
        ctx.fillText(p.text, p.x, y);
        ctx.restore();
      } else {
        const prog = p.t / p.dur;
        ctx.save();
        ctx.globalAlpha = 1 - prog;
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(0,0,0,0.30)";
        roundRect(W/2 - 210, 90, 420, 64, 14);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = "18px system-ui";
        ctx.fillText(p.text, W/2, 118);

        if (p.sub) {
          ctx.fillStyle = "rgba(255,255,255,0.78)";
          ctx.font = "13px system-ui";
          ctx.fillText(p.sub, W/2, 140);
        }
        ctx.restore();
      }
    }
  }

  function drawGameOver() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.58)";
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.textAlign = "center";
    ctx.font = "44px system-ui";
    ctx.fillText("GAME OVER", W/2, H/2 - 30);

    ctx.font = "18px system-ui";
    ctx.fillText(`Pontszám: ${score}`, W/2, H/2 + 10);
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.fillText("Nyomj R-t az újraindításhoz", W/2, H/2 + 42);
    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  // ---------- Reset / Loop ----------
  function reset() {
    score = 0;
    lives = 3;
    time = 0;
    gameOver = false;
    paused = false;

    obstacles.length = 0;
    bullets.length = 0;
    particles.length = 0;
    popups.length = 0;

    spawnInterval = 1200;
    baseSpeed = 70;
    maxObstacles = 2;
    player.x = W/2;
    player.y = H/2;
    player.cooldown = 0;
    player.lastWeapon = "j";

    // Start wave
    spawnObstacle();
    popups.push({ t: 0, dur: 1.0, text: "SZÓFUTAM", sub: "Töltsd fel az energiaslottot J/LY lövéssel!" });
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
